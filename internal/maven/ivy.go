package maven

import (
	"github.com/git-pkgs/manifests/internal/core"
	"encoding/xml"
	"strings"
)

func init() {
	core.Register("maven", core.Manifest, &ivyXMLParser{}, core.ExactMatch("ivy.xml"))

	// ivy-report.xml - lockfile (sbt dependencyLookup output)
	// Files are named {org}-{module}-{conf}.xml (e.g., com.example-hello_2.12-compile.xml)
	core.Register("maven", core.Lockfile, &ivyReportParser{}, ivyReportMatcher)
}

// ivyXMLParser parses ivy.xml files.
type ivyXMLParser struct{}

type ivyModule struct {
	Dependencies struct {
		Deps []ivyDep `xml:"dependency"`
	} `xml:"dependencies"`
}

type ivyDep struct {
	Org  string `xml:"org,attr"`
	Name string `xml:"name,attr"`
	Rev  string `xml:"rev,attr"`
	Conf string `xml:"conf,attr"`
}

func (p *ivyXMLParser) Parse(filename string, content []byte) ([]core.Dependency, error) {
	var module ivyModule
	if err := xml.Unmarshal(content, &module); err != nil {
		return nil, &core.ParseError{Filename: filename, Err: err}
	}

	var deps []core.Dependency
	seen := make(map[string]bool)

	for _, dep := range module.Dependencies.Deps {
		name := dep.Org + ":" + dep.Name
		if seen[name] {
			continue
		}
		seen[name] = true

		scope := core.Runtime
		// Check configurations before the -> (the local conf)
		localConf := dep.Conf
		if idx := strings.Index(localConf, "->"); idx > 0 {
			localConf = localConf[:idx]
		}
		// If local conf is only "test" (doesn't include "default"), it's test scope
		if strings.Contains(localConf, "test") && !strings.Contains(localConf, "default") {
			scope = core.Test
		}

		deps = append(deps, core.Dependency{
			Name:    name,
			Version: dep.Rev,
			Scope:   scope,
			Direct:  true,
		})
	}

	return deps, nil
}

// ivyReportMatcher matches ivy report files (e.g., com.example-hello-compile.xml)
func ivyReportMatcher(filename string) bool {
	// Match files ending in -compile.xml, -test.xml, -runtime.xml, etc.
	// These are generated by sbt's dependencyLookup command
	suffixes := []string{"-compile.xml", "-test.xml", "-runtime.xml", "-provided.xml"}
	for _, suffix := range suffixes {
		if strings.HasSuffix(filename, suffix) {
			return true
		}
	}
	return false
}

// ivyReportParser parses ivy report XML files.
type ivyReportParser struct{}

type ivyReport struct {
	Info         ivyReportInfo   `xml:"info"`
	Dependencies ivyReportDeps   `xml:"dependencies"`
}

type ivyReportInfo struct {
	Conf string `xml:"conf,attr"`
}

type ivyReportDeps struct {
	Modules []ivyReportModule `xml:"module"`
}

type ivyReportModule struct {
	Org       string            `xml:"organisation,attr"`
	Name      string            `xml:"name,attr"`
	Revisions []ivyReportRevision `xml:"revision"`
}

type ivyReportRevision struct {
	Name string `xml:"name,attr"`
}

func (p *ivyReportParser) Parse(filename string, content []byte) ([]core.Dependency, error) {
	var report ivyReport
	if err := xml.Unmarshal(content, &report); err != nil {
		return nil, &core.ParseError{Filename: filename, Err: err}
	}

	var deps []core.Dependency
	seen := make(map[string]bool)

	// Determine scope from the info conf attribute
	scope := core.Runtime
	conf := strings.ToLower(report.Info.Conf)
	if strings.Contains(conf, "test") {
		scope = core.Test
	}

	for _, mod := range report.Dependencies.Modules {
		name := mod.Org + ":" + mod.Name
		if seen[name] {
			continue
		}
		seen[name] = true

		version := ""
		if len(mod.Revisions) > 0 {
			version = mod.Revisions[0].Name
		}

		deps = append(deps, core.Dependency{
			Name:    name,
			Version: version,
			Scope:   scope,
			Direct:  false, // Ivy reports show resolved deps, not just direct
		})
	}

	return deps, nil
}
